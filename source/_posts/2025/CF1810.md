---
title: CodeTON Round 4 题解
katex: true
tag:
  - 算法竞赛
  - Codeforces
abbrlink: 4ded5892
date: 2025-06-19 00:00:00
---

避雷：H 我不会。

<!--more-->

随便写写吧：<https://codeforces.com/contest/1810>.

## A. Beautiful Sequence

如果有一个数满足 $a_i\geq i$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long i64;

void solve(void) {
    int n, flag = 0; cin >> n;
    for (int i = 1, x; i <= n; ++i) {
        cin >> x;
        if (x <= i) flag = 1;
    }
    cout << (flag ? "YES\n" : "NO\n");
}

int main(void) {
    ios::sync_with_stdio(0); cin.tie(0);
    int T = 1; cin >> T; 
    while (T--) solve();
    return 0;
}
```

## B. Candies

不难发现决策是唯一的。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long i64;

void solve(void) {
    int n; cin >> n; vector<int> ans;
    while (n % 2 && n > 1) {
        if ((n >> 1) & 1) ans.push_back(2), n >>= 1;
        else ans.push_back(1), n = (n >> 1) + 1;
    }
    if (n != 1) return cout << "-1\n", void();
    reverse(ans.begin(), ans.end());
    cout << ans.size() << "\n";
    for (int i : ans) cout << i << " "; cout << "\n";
}

int main(void) {
    ios::sync_with_stdio(0); 
    int T = 1; cin >> T; 
    while (T--) solve();
    return 0;
}
```

## C. Make It Permutation

枚举结束的数字即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long i64;
const int N = 1e5 + 5;

int n, c, d;
int a[N];

void solve(void) {
    cin >> n >> c >> d;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    sort(a + 1, a + n + 1);
    int m = unique(a + 1, a + n + 1) - (a + 1);
    i64 ans = 1ll * m * c + d;
    for (int i = 1; i <= m; ++i) ans = min(ans, 1ll * (a[i] - i) * d + 1ll * (m - i) * c);
    cout << ans + 1ll * c * (n - m) << "\n";
}

int main(void) {
    ios::sync_with_stdio(0); cin.tie(0);
    int T = 1; cin >> T; 
    while (T--) solve();
    return 0;
}
```

## D. Climbing the Tree



## G. The Maximum Prefix

直接做怎么做？设 $f_i$ 表示前 $i$ 个数，当前前缀和为 $j$，最大前缀和为 $k$，然后刷表转移对于每个状态是 $O(1)$ 的，炸了。

需要合并无效状态。考虑对于一段后缀，如果它本身的最大前缀和是 $0$，那么它不会对前面的贡献产生影响。也就是说，对于任意一段后缀，其能对整个序列的最大前缀和产生贡献的都是其最大前缀和。

设 $f_{i,j}$ 代表考虑前 $i$ 个数，且满足 $[i+1,n]$ 的最大前缀和为 $j$ 的期望答案。可以以 $p_i$ 的系数转移到 $f_{i+1,j-1}$，$1-p_i$ 的系数转移到 $f_{i+1,j+1}$。

答案便是 $f_{i,0}$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long i64;
const int P = 1000000007;
const int N = 5e3 + 5;

inline int poww(int a, int b) {
    int r = 1; 
    for (; b; b >>= 1, a = 1ll * a * a % P) if (b & 1) r = 1ll * r * a % P;
    return r;
}
inline int inv(int x) { return poww(x, P - 2); }
inline void add(int &x, i64 k) { x = (x + k) % P; }

int n;
int p[N];
int f[N][N];

void solve(void) {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        int x, y; cin >> x >> y;
        p[i] = 1ll * x * inv(y) % P;
    }
    for (int i = 0; i <= n + 2; ++i) for (int j = 0; j <= n + 2; ++j) f[i][j] = 0;
    for (int i = 0; i <= n; ++i) cin >> f[0][i];
    for (int i = 0; i < n; ++i)
        for (int j = 0; j <= n; ++j) if (f[i][j]) {
            // i + 1 位置填 1
            if (j) add(f[i + 1][j - 1], 1ll * p[i + 1] * f[i][j]); 

            // i + 1 位置填 -1
            add(f[i + 1][j + 1], 1ll * (1 + P - p[i + 1]) * f[i][j]);
            if (j == 0) add(f[i + 1][0], 1ll * (1 + P - p[i + 1]) * f[i][j]);
        }
    for (int i = 1; i <= n; ++i) cout << f[i][0] << " \n"[i == n];
}

int main(void) {
    ios::sync_with_stdio(0); cin.tie(0);
    int T = 1; cin >> T; 
    while (T--) solve();
    return 0;
}
```