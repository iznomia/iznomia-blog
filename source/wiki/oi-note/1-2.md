---
wiki: oi-note
title: 分治
katex: true
updated: 2025-12-29
---

分治是将复杂的问题拆成多个（一般是两个）相似的子问题，直到最后分成的子问题可以简单求解，然后通过子问题的答案合并出大问题的答案。

仿照分治的结构可以衍生出一大堆静态分治算法。

## 普通分治

### [uoj979] 决战库尔斯克

[Portal](https://uoj.ac/problem/979).

首先排序去重。如果选择钦定最小值，发现需要枚举最小值的倍数然后在一段中二分出最大值，但是值域很大，寄了。

那么钦定最大值，最小值可以选择严格比其一半大的，那么答案是差。假定最小的严格比一半大的是 $a_{mid}$。

考虑小于的部分对大于的部分的影响，枚举小数 $a_i$，发现需要 $a_i - 1 > a_r - a_{mid}$，这样就只有至多两段 $a_i$ 的倍数了，直接二分。

于是递归下去即可，$O(n\log V\log n)$，两个 log 都跑不满。[代码](https://uoj.ac/submission/810927)。

### * [CF1442D] Sum

{% box %}
[Portal](https://www.luogu.com.cn/problem/CF1442D).

给定 $n$ 个**不降**的数组。有一个值 $ans$，初始为 $0$。你需要进行如下操作 $k$ 次：

* 选择一个数组，把 $ans$ 加上数组的第一个元素，之后把它删除。

请求出 $ans$ 最大是多少。所有数组的元素总个数 $\leq 10^6$，$n,k\leq 3000$。
{% endbox %}

注意到数组是单调不降的，因此要取一个数组就会一直取下去直到不能取或者取光了。

所以可以想到一个暴力一点的做法：将一个数组视为一个有体积有价值的物品，然后正反做两遍 01 背包，枚举没取满的那个数组和这个数组取多少个，再枚举前面取的体积，这样就可以得出后面取的体积，并计算出总价值，时间复杂度为 $O(nk^2)$。

这样肯定过不去，发现就是合并太慢了，考虑使用分治算法合并：求解 $(l,r)$ 时，我们先将 $(l,mid)$ 加入背包，然后递归求解 $(mid+1,r)$，当 $l=r$ 时就可以枚举当前体积了。时间复杂度 $O(nk\log n)$。

> 这个问题被称为**缺一背包**，意思是其中有一个可以取不满，一般采用上述分治法解决。 

```cpp
int n, k;
vector<i64> a[3005];
i64 ans = 0, f[3005];

void merge(int l, int r) {
    if (l == r) {
        for (int i = 0; i <= min(k, (int)a[l].size() - 1); ++i)
            ans = max(ans, a[l][i] + f[k - i]);
        return;
    }
    int mid = l + r >> 1;
    i64 g[3005];
    memcpy(g, f, sizeof(g));
    for (int i = mid + 1; i <= r; ++i)
        for (int j = k; j >= a[i].size() - 1; --j)
            f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]);
    merge(l, mid);
    memcpy(f, g, sizeof(f));
    for (int i = l; i <= mid; ++i)
        for (int j = k; j >= a[i].size() - 1; --j)
            f[j] = max(f[j], f[j - a[i].size() + 1] + a[i][a[i].size() - 1]);
    merge(mid + 1, r);
}

int main(void) {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) {
        int m; scanf("%d", &m); a[i].resize(m + 1);
        for (int j = 1, x; j <= m; ++j) scanf("%lld", &a[i][j]), a[i][j] += a[i][j - 1];
    }
    merge(1, n); printf("%lld\n", ans);
    return 0;
}
```

## 二维分治

其实就是对两个东西进行分治，每次将其中一个东西切半（为了保证效率，一般选择其中区间更长的一个切半），然后合并答案。

{% box %}
[\[CF364E\] Empty Rectangles](https://www.luogu.com.cn/problem/CF364E).

给定一个 $n\times m(1\le n, m\le 2.5\times 10^3)$ 的 01 矩阵，询问有多少个子矩阵满足只有 $k(1\le k\le 6)$ 个 1。
{% endbox %}

本题要求恰好有 $k$ 个 1 的子矩形数量，我们将当前矩形劈成两半（以劈成左一半和右一半为例），那么符合条件的子矩形要么在左半，要么在右半，要么跨越中线。

考虑跨越中线的如何合并。我们枚举子矩形的上下边界，然后开个桶 $p$ 统计左半矩形所含 $1$ 数量小于 $i$ 时左边界的最小值（右半矩形同理），然后直接枚举左半边的 $1$ 的个数就可以统计了。[代码](https://codeforces.com/contest/364/submission/186773113)。